# -*- coding: utf-8 -*-
"""ConsensusForRoboticSwarms.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Z7z0cAFXmuqGKippi7mkgVAQpiJA4eat
"""

import numpy as np
from collections import namedtuple
import matplotlib.pyplot as plt
import random

"""Set constants and environment rreactions"""

# Define State
State = namedtuple('State', ['x', 'y', 'u'])

# # Parameters
# N = 100
# Nhalf = 50
# m = 50
# d = 10
# t = 35
# h = 40

# Zx = 0.1 * N
# Zy = 0.1 * N

# qx = 1.05 / N
# qy = 0.95 / N

# initial_state = State(Nhalf - Zx, Nhalf - Zy, 0)

# Define Reactions
reactions = [
      # x + y -> x + u
     {
        'name': 'cix',
        'guard': lambda s: s.x > 0 and s.y > 0 and s.u < N,
        'rate': lambda s: qx * s.x * s.y,
        'delta': lambda s: State(s.x, s.y-1, s.u+1)
    },
      # x + y -> y + u
    {
        'name': 'ciy',
        'guard': lambda s: s.x > 0 and s.x < N and s.u > 0,
        'rate': lambda s: qy * s.x * s.y,
        'delta': lambda s: State(s.x-1, s.y, s.u+1)
    },
      #u + x -> 2x
    {
        'name': 'rx',
        'guard': lambda s: s.x > 0 and s.x < N and s.u > 0,
        'rate': lambda s: qy * s.x * s.y,
        'delta': lambda s: State(s.x+1, s.y, s.u-1)
    },
      #u + y -> 2y
    {
        'name': 'ry',
        'guard': lambda s: s.y > 0 and s.y < N and s.u > 0,
        'rate': lambda s: qy * s.x * s.y,
        'delta': lambda s: State(s.x, s.y+1, s.u-1)
    },
      #y + Zx -> u + Zx
    {
        'name': 'zeaxa',
        'guard': lambda s: s.y > 0 and s.u < N and Zx > 0,
        'rate': lambda s: qx * s.y * Zx,
        'delta': lambda s: State(s.x, s.y-1, s.u+1)
    },
      #u + Zx -> x + Zx
    {
        'name': 'zeaxb',
        'guard': lambda s: s.u > 0 and s.x < N and Zx > 0,
        'rate': lambda s: qx * s.u * Zx,
        'delta': lambda s: State(s.x+1, s.y, s.u-1)
    },
      #x + Zy -> u + Zy
        {
        'name': 'zeaya',
        'guard': lambda s: s.x > 0 and s.u < N and Zy > 0,
        'rate': lambda s: qy * s.y * Zy,
        'delta': lambda s: State(s.x-1, s.y, s.u+1)
    },
      #u + Zy -> y + Zy
    {
        'name': 'zeayb',
        'guard': lambda s: s.u > 0 and s.y < N and Zy > 0,
        'rate': lambda s: qy * s.u * Zy,
        'delta': lambda s: State(s.x, s.y+1, s.u-1)
    }
]

# Define Label Functions
def x_wins(s, Zx, m, d):
    return (s.x + Zx >= m) and (s.x >= s.y + d)

def y_wins(s, Zy, m, d):
    return (s.y + Zy >= m) and (s.y >= s.x + d)
def consensus(s):
  return x_wins or y_wins
def robust_consensus(s, tr_t, hold_time, t, h, Zy, Zx, m, d):
  return consensus(s) and tr_t <= t and h <= hold_time

# Example: Gillespie SSA
import random

# [useful reference for this function's implementation](https://lewiscoleblog.com/gillespie-algorithm)
def gillespie_simulation(state, Tmax=100):
    time = 0
    trajectory = [(time, state)]
    while time < Tmax:
        propensities = []
        for r in reactions:
            if r['guard'](state):
                propensities.append(r['rate'](state))
            else:
                propensities.append(0)
        total_rate = sum(propensities)
        if total_rate == 0:
            break
        time += random.expovariate(total_rate)
        chosen = random.choices(reactions, weights=propensities)[0]
        state = chosen['delta'](state)
        trajectory.append((time, state))
    return trajectory

def plot_trajectories(trajectories, T_ave, X_ave, Y_ave, U_ave):
    fig, axs = plt.subplots(3, 1, figsize=(10, 18))

    # Plot average trajectories with thicker lines
    axs[0].plot(T_ave, X_ave, color='red', linewidth=3, label='Average X')
    axs[0].set_title('Average Number of X')
    axs[0].set_ylabel('Number of X')

    axs[1].plot(T_ave, Y_ave, color='green', linewidth=3, label='Average Y')
    axs[1].set_title('Average Number of Y')
    axs[1].set_ylabel('Number of Y')

    axs[2].plot(T_ave, U_ave, color='blue', linewidth=3, label='Average U')
    axs[2].set_title('Average Number of U')
    axs[2].set_xlabel('Time')
    axs[2].set_ylabel('Number of U')

    # Plot individual trajectories
    for traj in trajectories:
        times = [t for t, s in traj]
        xs = [s.x for t, s in traj]
        ys = [s.y for t, s in traj]
        us = [s.u for t, s in traj]
        axs[0].plot(times, xs, color='grey', alpha=0.3)
        axs[1].plot(times, ys, color='grey', alpha=0.3)
        axs[2].plot(times, us, color='grey', alpha=0.3)

    # Final adjustments
    for ax in axs:
        ax.grid(True)
        ax.legend()

    plt.tight_layout()
    plt.show()

def run_cross_inhibition_simulation(
      cycles=100,
      Tmax=50,
      N=100,
      Nhalf=50,
      m=50,
      d=10,
      h=40,
      Zx=10,
      Zy=10,
      qx=1.05/100,
      qy=0.95/100,
      initial_state=State(50 - 10, 50 - 10, 0),
      ave_steps=200,
      plot=False,
      print_params=True
      ):
    if Nhalf is None:
        Nhalf = N // 2
    # !!! how to determine these transition rates?
    if qx is None:
        qx = 1.05 / N
    if qy is None:
        qy = 1.05 / N
    if initial_state is None:
        initial_state = State(Nhalf - Zx, Nhalf - Zy, 0)

    if print_params:
          # Print parameters
          print("Running Cross-Inhibition Simulation with the following parameters:")
          print(f"  cycles      = {cycles}")
          print(f"  Tmax        = {Tmax}")
          print(f"  N           = {N}")
          print(f"  Nhalf       = {Nhalf}")
          print(f"  m           = {m}")
          print(f"  d           = {d}")
          print(f"  h           = {h}")
          print(f"  Zx          = {Zx}")
          print(f"  Zy          = {Zy}")
          print(f"  qx          = {qx:.5f}")
          print(f"  qy          = {qy:.5f}")
          print(f"  ave_steps   = {ave_steps}")
          print(f"  InitialState= (x={initial_state.x}, y={initial_state.y}, u={initial_state.u})")
          print("="*50)


    # Run multiple trajectories
    trajectories = [gillespie_simulation(initial_state) for _ in range(cycles)]

    # Average trajectories
    T_ave = np.linspace(0, Tmax, ave_steps+1)
    X_ave, Y_ave, U_ave = np.zeros(ave_steps+1), np.zeros(ave_steps+1), np.zeros(ave_steps+1)

    # Count robust consensus occurrences
    robust_consensus_count = 0
    for traj in trajectories:
        holding = False
        hold_start = None
        for i in range(len(traj)-1):
            t0, s0 = traj[i]
            t1, s1 = traj[i+1]
            if consensus(s0):
                if not holding:
                    hold_start = t0
                    holding = True
                elif t1 - hold_start >= h and hold_start <= t:
                    robust_consensus_count += 1
                    break
            # if robust_consensus(t1, hold_time, h, Zy, Zx, m, d):
              # robust_consensus_count += 1
            else:
                holding = False
                hold_start = None

    # Compute averages
    for i, t_point in enumerate(T_ave):
        X_sum, Y_sum, U_sum, count = 0, 0, 0, 0
        for traj in trajectories:
            for j in range(len(traj)-1):
                t0, s0 = traj[j]
                t1, s1 = traj[j+1]
                if t0 <= t_point < t1:
                    X_sum += s0.x
                    Y_sum += s0.y
                    U_sum += s0.u
                    count += 1
                    break
        if count > 0:
            X_ave[i] = X_sum / count
            Y_ave[i] = Y_sum / count
            U_ave[i] = U_sum / count
        else:
            if i > 0:
                X_ave[i], Y_ave[i], U_ave[i] = X_ave[i-1], Y_ave[i-1], U_ave[i-1]
            else:
                X_ave[i], Y_ave[i], U_ave[i] = initial_state.x, initial_state.y, initial_state.u

    print(f"Robust consensus reached {robust_consensus_count} times.")

    if plot:
        plot_trajectories(trajectories, T_ave, X_ave, Y_ave, U_ave)

    # Return summary
    return {
        # 'trajectories': trajectories,
        # 'T_ave': T_ave,
        # 'X_ave': X_ave,
        # 'Y_ave': Y_ave,
        # 'U_ave': U_ave,
        'robust_consensus_count': robust_consensus_count,
        'robust_consensus_prob': robust_consensus_count/len(trajectories)
    }

"""Find the probability that the system finds consensus with parameters m = 50, d = 10, t = 35,
h = 40, if there are total of N = 100 agents, out of which twenty are zealots (ZX = ZY = 10), and
initially there are 40 agents of type X and 40 agents of type Y .
"""

result = run_cross_inhibition_simulation(cycles=100, Tmax=20)
print(result)

"""# EXPERIMENTS

## Explore how the probability change when varying values of zealots Zx, Zy

Same number of zealots for both X and Y
"""

zealot_percentages = [0.0, 0.05, 0.15, 0.2, 0.3, 0.5]
same_n_zealots_exp = {}
for p in zealot_percentages:
  result = run_cross_inhibition_simulation(
      cycles=100,
      Tmax=50,
      N=100,
      Nhalf=50,
      m=50,
      d=10,
      h=40,
      Zx=p*100,
      Zy=p*100,
      qx=1.05/100,
      qy=0.95/100,
      initial_state=State(50 - p*100, 50 - p*100, 0),
      plot=False,
      print_params=True
      )
  same_n_zealots_exp[p] = result

"""How is it possible that consensus is reached so often? In the paper anything after 30% zealots threatens ever reaching consensus. !!! need to investigate

Different number of zealots for X and Y
"""

# growing percentage of zealots for x
vary_x_zealots_exp = {}
for p in zealot_percentages:
  result = run_cross_inhibition_simulation(N=100,cycles=100, Tmax=20, Zx=N*p, plot=False, print_params=True)
  vary_x_zealots_exp[p] = result
# growing percentage of zealots for y
vary_y_zealots_exp = {}
for p in zealot_percentages:
  result = run_cross_inhibition_simulation(N=100,cycles=100, Tmax=20, Zx=N*p, plot=False, print_params=True)
  vary_y_zealots_exp[p] = result

"""Explore how group size N affects consensus probability"""

group_size = [10, 20, 50, 100, 200, 100, 10000]
same_n_zealots_exp = {}
for g in group_size:
  print(f"SIMULATION WITH Zx:{N*p}, Zy:{N*p}")
  result = run_cross_inhibition_simulation(N=g,cycles=100, Tmax=50, plot=False, print_params=True)
  same_n_zealots_exp[p] = result

"""!!! strange results check parameters of simulation function
However for small values they seem to work: it's easier to reach consensus either if:
- there is a disproportionate amount of zealots for one side
- there is enough time in general for one group to reach and hold majority

Instead, we see no convergence:
- when there is a big number of zealots
- for small group sizes(??!! not sure, investigate)
"""